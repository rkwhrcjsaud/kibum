# [Gold V] 행렬분할 - 23318 

[문제 링크](https://www.acmicpc.net/problem/23318) 

### 성능 요약

메모리: 2020 KB, 시간: 920 ms

### 분류

백트래킹, 비트마스킹, 브루트포스 알고리즘, 누적 합

### 제출 일자

2024년 4월 2일 22:44:07

### 문제 설명

<p>n × m 크기의 행렬이 있다. 이 행렬을 가로로 a번, 세로로 b번 잘라 (a + 1) × (b + 1) 개의 부분으로 분할하려고 한다. 이 때, 같은 부분을 두 번 이상 자를 수는 없다. 즉, 한 개의 원소도 포함되지 않은 부분은 존재할 수 없다.</p>

<table class="table table-bordered td-center td-middle">
	<tbody>
		<tr>
			<td><img alt="" src="https://upload.acmicpc.net/730b5edd-6913-472b-bec5-d92069cc8db5/-/preview/" style="width: 148px; height: 125px;"></td>
			<td><img alt="" src="https://upload.acmicpc.net/6d2492a4-a468-4f04-9e11-2a39c3366a6c/-/preview/" style="width: 179px; height: 147px;"></td>
		</tr>
		<tr>
			<td>그림 1</td>
			<td>그림 2</td>
		</tr>
	</tbody>
</table>

<p>위 그림 1과 같은 6 × 7 행렬이 있을 때, 이 행렬을 가로로 2번, 세로로 3번 자르면 그림 2와 같이 된다.</p>

<p>분할의 '점수' 는 잘라진 각 부분의 합들 중에서 가장 큰 값으로 정의한다. 예를 들어, 그림 2와 같은 분할에서의 점수는 색칠한 부분의 합인 19이다. 최소로 분할하면 점수는 15이고, 그림은 생략한다.</p>

<p>행렬이 주어졌을 때 가능한 최소 점수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 자연수 n(2 ≤ n ≤ 20)과 m(2 ≤ m ≤ 8)의 값이 주어진다. 두 번째 줄에는 자연수 a(1 ≤ a < n), b(1 ≤ b < m) 의 값이 주어진다. 세 번째 줄부터 차례로 n개의 줄에는 행렬의 원소들이 공백으로 구분되어 주어진다. 행렬의 모든 원소들은 15 이하의 자연수이다. </p>

### 출력 

 <p>첫 번째 줄에 최소 점수를 출력한다.</p>

